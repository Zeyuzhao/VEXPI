#pragma config(Sensor, in1,    lightSensor,    sensorReflection)
#pragma config(Sensor, in2,    tempSensor,    sensorReflection)
#pragma config(Sensor, in3,    saltSensor,    sensorReflection)
#pragma config(Sensor, in4,    windSensor,    sensorReflection)

#pragma config(Motor,  port1,           leftMotorF,    tmotorNone, openLoop)
#pragma config(Motor,  port2,           leftMotorB,    tmotorNone, openLoop)
#pragma config(Motor,  port3,           claw,          tmotorNone, openLoop)
#pragma config(Motor,  port4,           lightServo,    tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           rightMotorB,   tmotorNone, openLoop)
#pragma config(Motor,  port10,          rightMotorF,   tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "BNSlib_HC05.h"
#include "SensorUtils.h"

/*
Data buttons:

Remember:

Left -> RIGHT
First Find the SUN, then go to the POND

U -> Upload DATA
D -> Drop the dropFlag

Btn7L: SUN find
Btn7R: POND find
Btn7U: DATA Upload
*/

const int LIGHT_EPISLON = 3;

//START OF UTIL FUNCTIONS ------------------------------------------------------------------------------

/*
Sends a set of 4 numbers, delimited by commas, to the raspberry pi
*/
void sendSerial(int temp, int light, int salt, int wind)
{
	// Create buffer to manipulate array of chars
	char buffer[100];
	//Use sprintF to format the char array for input data
	sprintf(buffer, "%d, %d, %d, %d", temp, lit, salt, wind);
	writeDebugStream(buffer);
	//Send buffer to UART
	bnsSerialSend(UART2, buffer);
}

void updateMotors()
{
	//Set Left Side
	motor[leftMotorF] = vexRT[Ch3];
	motor[leftMotorB] = vexRT[Ch3];

	//Set Right Side
	motor[rightMotorF] = vexRT[Ch2];
	motor[rightMotorB] = vexRT[Ch2];
}

void stopMoving() {
	motor[leftMotorF]  = 0;
	motor[leftMotorB]  = 0;
	motor[rightMotorF]  = 0;
	motor[rightMotorB]  = 0;
}

//Use this if pause interupts multitasking
void safePause(int mili)
{
	clearTimer(T2);
	while(time1[T2] < mili)
	{
		//Do Nothing
	}
	clearTimer();
}
//END OF UTIL FUNCTIONS ------------------------------------------------------------

//START OF SUB HELPERS ------------------------------------------------------------------------

//Less is Brighter
int maxBrightFlat()
{
	int b = 1024;
	clearTimer(T1);
	while (time1[T1] < 11*1000) {
		motor[leftMotorB] = 50;
		motor[rightMotorF] = 50;
		if (SensorValue(lightSensor) < b) {
			b = SensorValue(lightSensor);
		}
	}
	stopMoving();
	return b;
}

int maxBrightVert()
{
	int b = 1024;
	for (int i = MIN_SERVO; i < MAX_SERVO; i += 5){
		motor[lightServo] = i; //Set position
		wait1Msec(100); //Wait for 0.2 second
		int c = SensorValue(lightSensor);
		if (c < b) {
			b = c;
		}
	}
	return b;
}

int findBrightFlat(int b)
{
	clearTimer(T1);
	while(time1[T1] < 30*1000) {
		motor[leftMotorB] = 50;
		motor[rightMotorF] = 50;
		if (abs(SensorValue(lightSensor) - b) < LIGHT_EPISLON) {
			stopMoving();
			return time1[T1];
		}
	}
	stopMoving();
	return -1;
}


//Find the MAX_SERVO values
int findBrightVert(int b)
{
	for (int i = MIN_SERVO; i < MAX_SERVO; i += 5){
		motor[lightServo] = i; //Set position
		wait1Msec(100); //Wait for 0.2 second
		if (abs(SensorValue(lightSensor) - b) < t) {
			return i; //If within bounds, stop and return current angle
		}
	}
	return -128;
}

//END OF SUB HELPERS ---------------------------------------------------------------


//START OF SUBROUTINES------------------------------------------------------------------------


//IMPLEMENT
void findSun()
{
	int maxFlatVal = maxBrightFlat();
	wait1Msec(1000);
	findBrightFlat(maxFlatVal);
	wait1Msec(1000); //Check if it interferes with data transmission

	int maxHeightVal = maxBrightVert();
	findBrightVert(maxFlatVal);
	wait1Msec(3000);

}


//IMPLEMENT
void findPond(){

}

//IMPLEMENT
void dropFlag()
{
	//Wait for checking time
	motor[claw] = 30;
}
//END OF SUBROUTINES------------------------------------------------------------------------

//START OF TASKS------------------------------------------------------------------------------
//Tasks are used to multitask, run each task at the same time

/*
Controls movement and subroutines
VEX controller controls whether a subroutine should be preformed
*/
task readController(){
	//Read motor data
	//Execute Subroutines
	while(true){
		//Set motors to appropiate speedsd
		updateMotors();

		if (vexRT[Btn7L] == 1) {
			//Execute SUN Finder
			stopMoving();
			findSun(); //IMPLEMENT
		}

		if (vexRT[Btn7R] == 1) {
			//Execute AUTO Pond Trail
			stopMoving();
			findPond(); //IMPLEMENT
		}

		if (vexRT[Btn7D] == 1) {
			//Execute AUTO Pond Trail
			stopMoving();
			dropFlag(); //IMPLEMENT
		}
	}
}

/*
Transmits data to Raspberry Pi
*/
task dataCollection(){
	while(true)
	{
		//Data BUTTON
		if (vexRT[Btn7U] == 1){
			int temp = readTemp();
			int light = readLight();
			int salt = readSalt();
			int wind = readWind(); //This function takes at least 2 secs
			sendSerial(temp, light, salt, wind);
		}
	}
}
//END OF TASKS----------------------------------------------------------------------------------------

task main()
{
	//Use Multitasking to transmit data while preforming tasks and movement
	startTask(dataCollection);
	startTask(readController);
}
